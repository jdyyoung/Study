

---

---

###                                           内核驱动内存管理复习

4.linux内核的内存访问
  4.1.概念：
  明确：不管是用户空间还是内核空间,程序访问的地址都是虚拟地址
  明确：CPU最终访问的地址必然是物理地址,虚拟地址转换成物理地址是通过MMU硬件逻辑单元
  明确：有些CPU没有MMU,也能运行衍生版的linux(uclinux)
  明确：4G虚拟内存，用户空间每个进程独占前3G虚拟内存(0x0~0xBFFFFFFF)
  明确：4G虚拟内存,内核空间占后1G虚拟内存(0xC0000000~0xFFFFFFFF)
  明确：用户空间只能最大访问3G的物理内存
  明确：内核空间能够访问所有的物理内存
  明确：一个物理地址可以有多个虚拟地址,一个虚拟地址不能对应多个物理地址

  4.2.虚拟内存和物理内存的映射关系
  虚拟内存分为：用户虚拟内存和内核虚拟内存
  	用户虚拟内存和物理内存的映射采用动态映射(用户需要访问某块物理内存,内核会动态创建用户虚拟内存和物理内存的映射关系(页表)),如果将来不再访问,   需要将这种映射关系解除，动态映射的缺点在于内存访问的效率不高！

  	内核虚拟内存和物理内存的映射采用静态映射(又称一一映射),在内核启动初始化的时候就已经完成这种一一映射关系,将来内核只需直接访问即可,无需再次建立映射关系,加快内存的访问效率：
  物理地址		内核虚拟地址
  0x00000000		0xC0000000
  0x00000001		0xC0000001
  0x00000002            0xC0000002
  ...			...
  问题：如果采用一一映射,内核访问内存的效率得到提高,但是内核只能访问1G的物理内存,无法访问多余的物理内存,内核如何访问其余的物理内存或者任何一个设备的物理地址呢？

  内核将1G的内核虚拟内存进行分区划分,既满足内存访问的效率,又能满足内核能够访问所有的物理内存：
  1G内核虚拟内存的划分如下：
  对于X86架构，1G虚拟内存的划分：
  1G内核虚拟内存的地址由低向高：
  	
  直接内存映射区：
  		特点：
  		内核初始化时,将1G内核虚拟内存的前896M跟**物理内存的前896M**进行一一映射,这块虚拟内存的访问效率要高，这块内核虚拟内存区域又称低端内存(lowmem)
  		
 动态内存映射区:
  		特点：
  		如果要访问其余的物理内存或者任何一个物理地址,可以将物理内存和物理地址跟动态内存映射区的内核虚拟内存或者地址进行映射(建立页表),如果不在使用，记得要解除地址映射；缺点是内存的访问效率不高，但是能够保证访问所有的物理内存和地址，默认大小为120M
  		
  	永久内存映射区：(kmap)
  	固定内存映射区：(kmap_atomic)
  		特点：
  		永久就是固定，固定就是永久，如果对某块物理内存或者某个物理地址要频繁的访问，可以将此地址跟永久或者固定内存映射区的虚拟内存进行映射,不再使用时，可以不用解除地址映射,优点是即可访问其余的物理内存或者地址,也加快内存的访问效率
  		前者用于进程上下文
  		后者用于中断上下文
  		各占4M
  	动态内存映射区+永久+固定 = 高端内存
  	
  S5PV210处理器1G内核虚拟内存的划分：启动开发板，查看内核打印信息：
    Virtual kernel memory layout:
    区域名称   起始地址    结束地址       大小
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)  //异常向量表
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB) //固定内存映射区
    DMA     : 0xff000000 - 0xffe00000   (  14 MB) //DMA内存映射区
    vmalloc : 0xf4800000 - 0xfc000000   ( 120 MB)  //动态内存映射区
    lowmem  : 0xc0000000 - 0xf4000000   ( 832 MB)  //直接内存映射区
    modules : 0xbf000000 - 0xc0000000   (  16 MB)  //模块
    .init : 0xc0008000 - 0xc0037000   ( 188 kB)  //初始化段
    .text : 0xc0037000 - 0xc0838000   (8196 kB) //代码段
    .data : 0xc0838000 - 0xc088c900   ( 339 kB) //数据段

---

`GFP_` ("get free page")：GFP_KERNEL or SLAB_KERNEL? - 程序园 - http://www.voidcn.com/article/p-frwawxpb-bbq.html

4.3.linux内核内存分配的方法：
    4.3.1.kmalloc/kfree
    函数原型：
    void *kmalloc(size_t size, gfp_t flags)
    函数功能：
    	**从直接内存映射区分配内存**
    	物理,虚拟都连续
    	内存的大小为最小为32字节，最大为4M
    参数：
    size:指定分配内存的大小
    flags:指定分配内存时的行为,一般指定为：
          GFP_KERNEL:告诉内核,请努力帮我把这次内存分配搞定,如果内存不足 ,会导致休眠,不能用于中断上下文,成功概率比较大
          GFP_ATOMIC:如果分配内存，内存不足,不会导致休眠,立即返回，可以用于中断上下文，成功概率比较小
    返回值：返回分配的内核起始虚拟地址
    

void kfree(void *addr)
函数功能：释放分配的内核虚拟内存
参考代码：
void *addr;
addr = kmalloc(0x100000, GFP_KERNEL);
kfree(addr);

---

4.3.2. get_free_pages/free_pages
	**1page=1页=4K**
    函数原型：
	unsigned long get_free_pages(gfp_t gfp_mask, unsigned int order)
    函数功能：
    	**从直接内存映射区分配**
    	物理，虚拟都连续
    	最小为1页，最大为4M
    mask:指定分配内存时的行为,一般指定为：
          GFP_KERNEL:告诉内核,请努力帮我把这次内存分配搞定,如果内存不足 ,会导致休眠,不能用于中断上下文,成功概率比较大
          GFP_ATOMIC:如果分配内存，内存不足,不会导致休眠,立即返回，可以用于中断上下文，成功概率比较小
    order:	
    	  order = 0 分配1页
    	  order = 1 分配2页
    	  order = 2 分配4页
    	  order = 3 分配8页
    	  ...
返回值：返回分配的内核起始虚拟地址,注意数据类型的转换！
    

free_pages(unsigned long addr, int order)
释放分配的内存

---

4.3.3.vmalloc/vfree
    函数原型：
    void *vmalloc(int size)
    函数功能：
    	从动态内存映射区分配内存
    	虚拟上连续,物理上不一定连续
    	如果内存不足,会导致休眠，**不能用于中断上下文**
    	最大理论上默认120M
    返回值：返回起始的虚拟地址

void vfree(void *addr) //释放内存

4.3.4.定义全局数组
	static char g_buf[5*1024*1024]; 
    

4.3.5.在内核的启动参数中指定vmalloc=250M,告诉内核将内核的动态内存映射区的大小由默认的120M扩展到250M	
    例如：
    setenv bootargs root=/dev/nfs nfsroot=... vmalloc=250M
    saveenv
    boot
    再观察内核的1G虚拟内存的分配

---

4.3.6.在内核的启动参数中指定mem=10M,告诉内核将**物理内存的最后10M**预留出来,预留给驱动单独使用,利用**ioremap函数进行映射即可访问**

    setenv bootargs root=/dev/nfs nfsroot=... mem=10M
    saveenv
    boot
    //将来驱动利用ioremap函数将这10M的物理内存进行映射，即可访问
5.linux内核大名鼎鼎的**ioremap**函数
  明确：不论是在用户空间还是在内核空间,一律不允许访问物理地址
  明确：如果要访问**外设的物理地址**必须要进行地址映射,将物理地址要不映射到用户的虚拟地址上，要不映射到内核的虚拟地址上,一旦映射完毕,将来访问这个虚拟地址就是在访问对应的物理地址   

  问：如何**将设备的物理地址和物理内存映射到内核空间的虚拟地址和内存上**呢
  答：利用**ioremap函数**即可完成映射
  函数原型：
  void *ioremap(unsigned long phys_addr, int size)
  函数功能：
  	将物理内存或者地址映射到内核的虚拟内存或者地址上
  	将来访问这个内核虚拟内存或者地址就是在访问对应的物理内存和地址
  参数：
  phys_addr:要映射的物理起始地址
  size:物理内存的大小
  "物理内存"：不单单指内存条,外设对应的寄存器也通常称之为物理内存

  返回值：返回映射的对应内核起始的虚拟地址
  例如：
  LED1，LED2对应的GPIO分别为GPC0_3和GPC0_4
  对应的配置寄存器和数据寄存器的物理地址分别为0xE0200060,0xE0200064
  第一种映射关系：
  物理地址		内核虚拟地址
  0xE0200060            A
  0xE0200064            B
  unsigned long *gpiocon, *gpiodata; //配置和数据寄存器的内核虚拟地址
  A = gpiocon = ioremap(0xE0200060, 4);
  B = gpiodata = ioremap(0xE0200064, 4);
  //配置输出：
  *gpiocon &= ~(...)
  *gpiocon |= (...)

  第二种映射关系：
  物理地址		内核虚拟地址
  0xE0200060		A
  0xE0200064		B = A+0x4
  unsigned long *gpiocon, *gpiodata; //配置和数据寄存器的内核虚拟地址
  A = gpiocon = ioremap(0xE0200060, 8);
  B = gpiodata = gpiocon + 1;

  解除地址映射：iounmap(映射的内核起始虚拟地址);

  案例：利用ioremap直接对寄存器访问实现开关灯

  小项目：寄存器操作软件
  需求：能够随时随地来读或者写任何一个寄存器
  提示：用户和内核数据交互采用：
  struct reg_info {
  	unsigned long reg_phys_addr; //传递要操作的寄存器物理地址
  	unsigned long reg_data; //传递寄存器的数据
  };

---

2.linux内核硬件操作方法之mmap机制
2.1.回顾LED驱动和按键驱动
分析以前的驱动发现,read,write,ioctl三个系统调用对设备的访问,不论读还是写都要经过两次数据拷贝过程：用户和内核，内核和硬件物理内存
  对于LED开关：用户到内核，内核到硬件寄存器
  对于按键：硬件寄存器到内核，内核到用户
  如果数据的访问量比较小(蚊子),两次的数据拷贝对系统性能影响几乎可以忽略不计
  如果数据的访问比较大(响尾蛇),两次的数据拷贝势必影响系统性能
  数据的操作的规律是源要不是用户或者硬件,目的要不是硬件或者用户,而内核仅仅作为一个缓冲,所以用户到内核的数据拷贝是多余的,如果让用户在用户空    间访问硬件设备的物理内存,即可将两次数据拷贝变成一次数据拷贝
  以下设备的数据量的访问比较大：摄像头,声卡,显卡,LCD等

  明确：不管是用户空间还是内核空间一律不允许访问物理地址,只能访问虚拟地   址

  问：如何让用户在用户空间访问到硬件设备的物理地址呢？将数据的拷贝由2次变成1次，加快数据的访问速度呢？
  答：利用大名鼎鼎的**mmap机制**

  2.2.硬件操作方法之mmap机制
  作用：仅仅将设备物理地址映射到用户空间的虚拟地址上,一旦映射完毕,对设备的访问将来都放在用户空间来进行
  回顾mmap系统调用的使用：
  void *addr;
  fd  = open("a.txt", ...);
  addr = mmap(0, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
  memcpy(addr, "hello,world", 12);
  作用：将文件a.txt(硬盘物理信息)映射到用户3G虚拟地址空间中的MMAP虚拟内存映射区中,一旦映射完毕将来访问用户的这块虚拟内存就是在访问对应	的物理地址(物理内存),不再经过内核的数据拷贝，加快文件的访问速度

  第一个实参0:告诉内核,请在当前进程的3G虚拟地址空间的MMAP内存映射区中找一块空闲的虚拟内存用来映射文件
  第二个实参0x1000:空闲的用户虚拟内存的大小,必须是页面大小的整数倍
  返回值addr:内核将内核帮你找的那块空闲虚拟内存区域的首地址返回到用户空间,将来用户在用户空间访问这块虚拟内存就是在访问硬件的物理地址

  对应底层驱动的mmap接口：
  struct file_operations {
  	int (*mmap)(struct file *file,
  			struct vm_area_struct *vma);//指向内核创建的描			述空闲虚拟内存区域的对象
  };
  mmap系统调用过程：
  1.应用程序调用mmap系统调用函数,首先调用到C库的mmap函数实现
  2.C库的mmap函数将会做两件事：
    2.1.保存mmap的系统调用号到R7
    2.2.调用svc触发软中断异常
  3.进入内核准备好的软中断的处理入口,做两件事
    3.1.从R7寄存器中取出之前保存的mmap系统调用号
    3.2.以系统调用号为索引在系统调用表中找到对应的内核函数sys_mmap(内核
  4.sys_mmap将会做两件事：
    4.1.内核会在当前进程的3G的MMAP内存映射去中找一块空闲的虚拟内存,将来	用来映射物理地址(物理内存)
    4.2.一旦内核找到这块空闲的内存区域,内核用struct vm_area_struct结构	体创建一个对象来描述找到的这块空闲的虚拟内存
    	struct vm_area_struct {
    		unsigned long vm_start;	//空闲虚拟内存的起始地址,等于		mmap的返回值addr
    		unsigned long vm_end;//结束地址
    		pgprot_t vm_page_prot;//访问权限,保存用户传递来的属性
    		unsigned long vm_pgoff;//文件的偏移量
    		...
    	}
    4.3.最终再调用底层驱动的mmap接口,并且把创建的struct vm_area_struct	对象的首地址传递给底层驱动的mmap接口
  5.底层驱动mmap接口利用第二个形参vma指针即可获取空闲虚拟内存的属性,底层驱动的mmap将会做？
    答：底层驱动的mmap永远只做一件事：将物理地址映射到用户的虚拟地址上
    此时此刻底层驱动的mmap：有已知的物理地址,又有已知的用户虚拟地址(vma)

6.**底层驱动的mmap函数调用remap_pfn_range函数**即可完成物理地址到用户虚拟地址的映射,一旦完成映射，将来对设备的访问放在用户空间进行

```pfn（Page Fram Number）是虚拟地址应该映射到的物理地址的页面号
pfn（Page Fram Number）是虚拟地址应该映射到的物理地址的页面号
remap_pfn_range（）详解_yarsen的专栏-CSDN博客_remap_pfn_range - https://blog.csdn.net/teethfairy/article/details/8779632```
```

函数原型：
  int **remap_pfn_range**(struct vm_area_struct *vma, 
  				unsigned long addr,
		    		unsigned long pfn, 
		    		unsigned long size, 
		    		pgprot_t prot)

  函数功能：将物理地址映射到用户虚拟地址
  参数：
  vma:指向内核创建描述空闲虚拟内存区域的对象
  addr:空闲虚拟内存的起始地址vm_start
  pfn:将物理地址右移12位
  size:空闲虚拟内存的大小vm_end-vm_start
  prot:空闲虚拟内存的访问权限vm_page_prot
  切记：addr,pfn一定是页面大小的整数倍
  切记：如果对设备进行输入和输出的操作(GPIO),一定要关闭cache功能
  vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
  例如：
  物理地址		用户虚拟地址
  0xE0200000            vm_start
  0xE0200080            vm_start + 0x80
  0xE0200084            vm_start + 0x84

  案例：利用mmap机制实现开关灯

---

---

