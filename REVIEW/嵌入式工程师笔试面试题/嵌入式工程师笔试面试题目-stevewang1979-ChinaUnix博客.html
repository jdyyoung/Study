<!DOCTYPE html>
<!-- saved from url=(0808)http://cache.baiducontent.com/c?m=9d78d513d9d430aa4f9d90697c1cc011694381132ba6a3020fa28449e3732b4a5015e5ac57230775a2d27d1716de3a4b99f42173471450b48cb9fb5dacc8855e299f2644676d875665d70edeb85153c737912afede68f0cdf025e2a8c5a3ab4352ba44050c97f1fb035b489f78f1646bb0fac51b4f4811cafa3013e8580778c5781ce550f89075325ccbe1dc2c5bb32ac7121a80df41a74f64a154e441147e02e60ea609223b2db0117aaa533d73c3b106bb793e1c78fc5fb3ce9de1ad55cb87bc26988ccbab2e9f66edcfe1ee71342b04ed25c8adb8b03c6f4306cecaa94c826de2&p=8d6fcc1f85cc43f609bd9b7c58&newp=9b759a4783d912a05ab682684553d8304a02c70e3dc3864e1290c408d23f061d4862e7bb26261005d6c6776d05ab4e57eff1337723454df6cc8a871d81edc732&user=baidu&fm=sc&query=%C7%B6%C8%EB%CA%BD%B9%A4%B3%CC%CA%A6%B1%CA%CA%D4%C3%E6%CA%D4%CC%E2%C4%BF%2Dkinghannah%2DChinaUnix%B2%A9%BF%CD&qid=a0e3f0b600018307&p1=2 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
<!--<base href="http://blog.chinaunix.net/uid-26384989-id-4703946.html">--><base href=".">
<style>
body{position:relative}
body,form{margin:0!important;padding:0!important}
#bd_snap{font:13px arial;color:#000;background:#fff;text-align:left;padding:13px 0 0 20px}
#bd_snap_txt{clear:both;padding:10px 0 2px;line-height:24px;color:#333}
#bd_snap_note{color:#999;padding-bottom:10px}
#bd_snap a{font:13px arial;color:#00c;text-decoration:underline}
#bd_snap_note a{color:#999}
#bd_snap_head{width:860px;height:44px}
#bd_snap_logo{width:162px;height:38px;display:block;background:url(http://www.baidu.com/img/logo-snap.png) no-repeat;margin-right:15px;float:left}
#bd_snap_search{width:680px;position:absolute;left:209px;top:17px}
#bd_snap_kw{width:531px;margin-right: 0;height:24px;padding:4px 7px;padding:6px 7px 2px\9;font:16px arial;vertical-align:top;border: 1px solid #b6b6b6;border-color: #7b7b7b #b6b6b6 #b6b6b6 #7b7b7b;background: #fff;display:inline-block;border-right-width: 0;border-color: #b8b8b8 transparent #ccc #b8b8b8;overflow: hidden;outline:0}
#bd_snap_kw:hover{border-color: #999 transparent #b3b3b3 #999;}
#bd_snap_kw:focus{border-color: #4791ff transparent #4791ff #4791ff}
#bd_snap_su{width:100px;height:34px;font-size:14px;color:#fff;padding:0;letter-spacing: 1px;background: #3385ff; border-bottom: 1px solid #2d78f4;outline: medium;-webkit-appearance: none;-webkit-border-radius: 0;cursor:pointer;border:0}
#bd_snap_search input.bd_snap_btn_h{background: #3075dc;box-shadow: inset 1px 1px 3px #2964bb;-webkit-box-shadow: inset 1px 1px 3px #2964bb;-moz-box-shadow: inset 1px 1px 3px #2964bb;-o-box-shadow: inset 1px 1px 3px #2964bb;}
#bd_snap_search input.btnhover{background: #317ef3;border-bottom: 1px solid #2868c8;box-shadow: 1px 1px 1px #ccc;}
#bd_snap_btn_wr{width:97px;height:34px;display:inline-block;_top:1px;*position:relative}
#bd_snap_ln{height:1px;border-top:1px solid #ACA899;background:#ECE9D8;overflow:hidden}
#bd_snap_txt span a{text-decoration:none}
</style>


</head><body><div id="bd_snap">
    <div id="bd_snap_head">
        <a href="http://www.baidu.com/" id="bd_snap_logo" title="到百度首页"></a>
    </div>
    <div id="bd_snap_txt">您查询的关键词是：<span><a style="color:black;background-color:#ffff66;padding:0 3px;font-weight:bold" href="http://cache.baiducontent.com/c?m=9d78d513d9d430aa4f9d90697c1cc011694381132ba6a3020fa28449e3732b4a5015e5ac57230775a2d27d1716de3a4b99f42173471450b48cb9fb5dacc8855e299f2644676d875665d70edeb85153c737912afede68f0cdf025e2a8c5a3ab4352ba44050c97f1fb035b489f78f1646bb0fac51b4f4811cafa3013e8580778c5781ce550f89075325ccbe1dc2c5bb32ac7121a80df41a74f64a154e441147e02e60ea609223b2db0117aaa533d73c3b106bb793e1c78fc5fb3ce9de1ad55cb87bc26988ccbab2e9f66edcfe1ee71342b04ed25c8adb8b03c6f4306cecaa94c826de2&amp;p=8d6fcc1f85cc43f609bd9b7c58&amp;newp=9b759a4783d912a05ab682684553d8304a02c70e3dc3864e1290c408d23f061d4862e7bb26261005d6c6776d05ab4e57eff1337723454df6cc8a871d81edc732&amp;user=baidu&amp;fm=sc&amp;query=%C7%B6%C8%EB%CA%BD%B9%A4%B3%CC%CA%A6%B1%CA%CA%D4%C3%E6%CA%D4%CC%E2%C4%BF%2Dkinghannah%2DChinaUnix%B2%A9%BF%CD&amp;qid=a0e3f0b600018307&amp;p1=2#baidusnap0">嵌入式工程师笔试面试题目</a><a style="color:white;background-color:#886800;padding:0 3px;font-weight:bold" href="http://cache.baiducontent.com/c?m=9d78d513d9d430aa4f9d90697c1cc011694381132ba6a3020fa28449e3732b4a5015e5ac57230775a2d27d1716de3a4b99f42173471450b48cb9fb5dacc8855e299f2644676d875665d70edeb85153c737912afede68f0cdf025e2a8c5a3ab4352ba44050c97f1fb035b489f78f1646bb0fac51b4f4811cafa3013e8580778c5781ce550f89075325ccbe1dc2c5bb32ac7121a80df41a74f64a154e441147e02e60ea609223b2db0117aaa533d73c3b106bb793e1c78fc5fb3ce9de1ad55cb87bc26988ccbab2e9f66edcfe1ee71342b04ed25c8adb8b03c6f4306cecaa94c826de2&amp;p=8d6fcc1f85cc43f609bd9b7c58&amp;newp=9b759a4783d912a05ab682684553d8304a02c70e3dc3864e1290c408d23f061d4862e7bb26261005d6c6776d05ab4e57eff1337723454df6cc8a871d81edc732&amp;user=baidu&amp;fm=sc&amp;query=%C7%B6%C8%EB%CA%BD%B9%A4%B3%CC%CA%A6%B1%CA%CA%D4%C3%E6%CA%D4%CC%E2%C4%BF%2Dkinghannah%2DChinaUnix%B2%A9%BF%CD&amp;qid=a0e3f0b600018307&amp;p1=2#baidusnap7">-</a></span>  <span style="margin-left:5px">以下是该网页在北京时间 2018年11月13日 04:20:40 的快照；</span>
        <p>如果打开速度慢，可以尝试<a href="http://cache.baiducontent.com/c?m=9d78d513d9d430aa4f9d90697c1cc011694381132ba6a3020fa28449e3732b4a5015e5ac57230775a2d27d1716de3a4b99f42173471450b48cb9fb5dacc8855e299f2644676d875665d70edeb85153c737912afede68f0cdf025e2a8c5a3ab4352ba44050c97f1fb035b489f78f1646bb0fac51b4f4811cafa3013e8580778c5781ce550f89075325ccbe1dc2c5bb32ac7121a80df41a74f64a154e441147e02e60ea609223b2db0117aaa533d73c3b106bb793e1c78fc5fb3ce9de1ad55cb87bc26988ccbab2e9f66edcfe1ee71342b04ed25c8adb8b03c6f4306cecaa94c826de2&amp;p=8d6fcc1f85cc43f609bd9b7c58&amp;newp=9b759a4783d912a05ab682684553d8304a02c70e3dc3864e1290c408d23f061d4862e7bb26261005d6c6776d05ab4e57eff1337723454df6cc8a871d81edc732&amp;user=baidu&amp;fm=sc&amp;query=%C7%B6%C8%EB%CA%BD%B9%A4%B3%CC%CA%A6%B1%CA%CA%D4%C3%E6%CA%D4%CC%E2%C4%BF%2Dkinghannah%2DChinaUnix%B2%A9%BF%CD&amp;qid=a0e3f0b600018307&amp;p1=2&amp;fast=y">快速版</a>；如果想更新或删除快照，可以<a href="http://help.baidu.com/newadd?prod_id=1&amp;category=1&amp;link=http%3A%2F%2Fcache.baiducontent.com%2Fc%3Fm%3D9d78d513d9d430aa4f9d90697c1cc011694381132ba6a3020fa28449e3732b4a5015e5ac57230775a2d27d1716de3a4b99f42173471450b48cb9fb5dacc8855e299f2644676d875665d70edeb85153c737912afede68f0cdf025e2a8c5a3ab4352ba44050c97f1fb035b489f78f1646bb0fac51b4f4811cafa3013e8580778c5781ce550f89075325ccbe1dc2c5bb32ac7121a80df41a74f64a154e441147e02e60ea609223b2db0117aaa533d73c3b106bb793e1c78fc5fb3ce9de1ad55cb87bc26988ccbab2e9f66edcfe1ee71342b04ed25c8adb8b03c6f4306cecaa94c826de2%26p%3D8d6fcc1f85cc43f609bd9b7c58%26newp%3D9b759a4783d912a05ab682684553d8304a02c70e3dc3864e1290c408d23f061d4862e7bb26261005d6c6776d05ab4e57eff1337723454df6cc8a871d81edc732%26user%3Dbaidu%26fm%3Dsc%26query%3D%25C7%25B6%25C8%25EB%25CA%25BD%25B9%25A4%25B3%25CC%25CA%25A6%25B1%25CA%25CA%25D4%25C3%25E6%25CA%25D4%25CC%25E2%25C4%25BF%252Dkinghannah%252DChinaUnix%25B2%25A9%25BF%25CD%26qid%3Da0e3f0b600018307%26p1%3D2" id="bd_tousu">投诉快照</a>。
        </p>
    </div>
<script>document.getElementById('bd_tousu').href = 'http://help.baidu.com/newadd?prod_id=1&category=1&link=' + encodeURIComponent(document.location);</script>
    <div id="bd_snap_note">百度和网页 <a href="http://blog.chinaunix.net/uid-26384989-id-4703946.html">http://blog.chinaunix.net/uid-26384989-id-4703946.html</a> 的作者无关，不对其内容负责。百度快照谨为网络故障时之索引，不代表被搜索网站的即时页面。</div>
</div>
<div id="bd_snap_search">
	<form action="http://www.baidu.com/s"><input name="cl" type="hidden" value="3"><input name="wd" id="bd_snap_kw" maxlength="100"><span id="bd_snap_btn_wr"><input type="submit" id="bd_snap_su" value="百度一下" class="bd_snap_btn" onmouseover="this.className=&#39;bd_snap_btn bd_snap_btn_h&#39;" onmousedown="this.className=&#39;bd_snap_btn btnhover&#39;" onmouseup="this.className=&#39;bd_snap_btn&#39;" onmouseout="this.className=&#39;bd_snap_btn&#39;"></span></form>
</div>
<div id="bd_snap_ln"></div>
<div style="position:relative">




        <style>
    .Blog_nav1_2 a em { display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>

<link rel="stylesheet" type="text/css" href="http://blog.chinaunix.net/css/default/style.css">
<link rel="stylesheet" type="text/css" href="http://blog.chinaunix.net/css/qqface/qqFace.css">
<link rel="stylesheet" type="text/css" href="http://blog.chinaunix.net/css/asyncbox/skins/Chrome/asyncbox.css">
<link rel="stylesheet" type="text/css" href="http://blog.chinaunix.net/assets/f0409051/pager.css">



<title>嵌入式工程师笔试面试题目-stevewang1979-ChinaUnix博客</title>
<meta name="description" content="7.C++中为什么用模板类。答：(1)可用来创建动态增长和减小的数据结构（2）它是类型无关的，因此具有很高的可复用性。（3）它在编译时而不是运行时检查数据类型，保证了类型安全（4）它是平台无关的，可移植性（5）可用于基本数据类型8.CSin">








<div class="box">
  <!-- 一级导航 -->
  <div class="Blog_nav1">
    <div class="Blog_nav1_2"><a href="http://blog.chinaunix.net/"><img src="http://blog.chinaunix.net/image/default/1.png"></a><a href="http://www.chinaunix.net/" class="Blog_a1">Chinaunix首页</a> | <a href="http://bbs.chinaunix.net/" target="_blank">论坛</a> | <a href="http://u.it168.com/vip/"><font color="red">认证专区</font></a> | <a href="http://blog.chinaunix.net/" target="_blank">博客</a><span class="Blog_span1"></span>
              <a href="http://blog.chinaunix.net/site/login.html" class="Blog_a1" onclick="linkto()">登录</a> | <a href="http://u.it168.com/Register?webid=5&amp;returnUrl=http%3A%2F%2Fblog.chinaunix.net%2Fuid-26384989-id-4703946.html" class="Blog_a1">注册</a>
          </div>
	<!--自动提示层-->
	<style>
	.bor13221{border:1px #bbb solid;width:206px;position:absolute;top:34px;left:0;background:#fff; z-index:9999;display:none}
	.bor13221 li{height:26px;line-height:26px;padding-left:6px;color:#555;font-size:14px;cursor:pointer;}
	.here{background:#f3f3f3;}
    </style>

	<!--自动提示层-->
    <div class="Blog_nav1_3" style="position:relative; z-index:9999;">
	 <div class="bor13221">
      <ul>
      </ul>
    </div>
	  <form action="http://blog.chinaunix.net/site/search.html" method="post">
		<input type="text" autocomplete="off" class="Blog_txt1" id="search_input_id" name="keywords">
		<select class="Bolg_sel1" name="type" id="search_type_blog">
		  <option value="blog">博文</option>
		  <option value="author">博主</option>
		</select>
		<input type="submit" value="" name="submit" class="Blog_btn1">
	 </form>
    </div>
    <div class="clear"></div>
    <div class="Blog_nav1_layer1" id="message_slide_div" style="display:none;">
	    <ul>
	    	<li><a href="http://blog.chinaunix.net/message/private.html">私人消息()</a></li>
	    	<li><a href="http://blog.chinaunix.net/message/system.html">系统消息()</a></li>
	    	<li><a href="http://blog.chinaunix.net/member/request.html">好友请求()</a></li>
	    	<li><a href="http://blog.chinaunix.net/member/notification.html">通知管理()</a></li>
	    </ul>
    </div>
  </div>
   
  <!-- 头 -->
  <!-- 推荐博客-->
  <div class="Blog_header1">
	    <div class="Blog_header1_1">
      <p class="Blog_p1"><em><a href="http://blog.chinaunix.net/uid/26384989.html">stevewang1979的ChinaUnix博客</a></em>      </p><p class="Blog_p2" style="color:#125A94">暂无签名</p>
    </div>
        <div class="Blog_header1_2" id="hide_div1">
    	<span class="Blog_span3"></span>
    	<div class="float_div1" style="white-space:nowrap;" onmouseover="javascript:isMove=false" onmouseout="javascript:isMove=true">
	    <ul id="noticev2">  
		    		    <li><a href="http://blog.chinaunix.net/uid-30204791-id-5752644.html" target="_blank">2016中国系统架构师大会门票申请 </a></li>
		    		    <li><a href="http://blog.chinaunix.net/uid-24789255-id-5568211.html" target="_blank">新注册用户开通“博客写作”功能，需要申请与实名认证 </a></li>
		    		    <li><a href="http://blog.chinaunix.net/uid-10718265-id-5141960.html" target="_blank"> 互动：数据分析与云计算应用案例 （征集|参与）</a></li>
		    	    </ul>
	    </div>
    </div>
            <div class="Blog_header1_3"><a href="http://blog.chinaunix.net/uid/26384989.html">首页</a>　| 　<a href="http://blog.chinaunix.net/uid/26384989/abstract/1.html">博文目录</a>　| 　<a href="http://blog.chinaunix.net/member/profile/uid/26384989.html">关于我</a></div>
  </div>
    
  <!-- 内容部分 -->
  	 <!-- XRegExp is bundled with the final shCore.js during build -->


<link type="text/css" rel="stylesheet" href="http://blog.chinaunix.net/highlight/styles/shCore.css">
<link type="text/css" rel="Stylesheet" href="http://blog.chinaunix.net/highlight/styles/shThemeDefault.css">
<link href="http://blog.chinaunix.net/code/css/fck_editorarea.css" rel="stylesheet" type="text/css">
<style>
.Blog_p5 em{ display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>
  <div class="Blog_contain"> 
    <!-- 左 -->
	<style>
    .Blog_left1_1 p a em { display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>


<div class="Blog_left">
      <div class="Blog_left1 Blog_bg1">
        <div class="Blog_left1_1">
			<!-- 专家博客-->
			<a href="http://blog.chinaunix.net/uid/26384989.html">                            <img src="http://passport.ixpub.net/avatar.php?uid=26384989&amp;size=middle">
                        </a>
                        <p><a href="http://blog.chinaunix.net/uid/26384989.html">stevewang1979</a></p>
                     </div>
        <ul class="Blog_ul1 Blog_noline1">
          <li>博客访问： 61721 </li>
          <li>博文数量： 80 </li>
          <li>博客积分： 55 </li>
          <!--<li>专家积分： 180</li>-->
          <li>博客等级： 民兵 </li>
		  <li>技术积分： 26 </li>
          <li>用  户  组：  普通用户</li>
          <li>注册时间： 2012<a name="baidusnap7"></a><b style="color:white;background-color:#886800">-</b>02<b style="color:white;background-color:#886800">-</b>21 17:54 </li>
                            </ul>  


        
                <div class="HT_line3 HT_line3_1"></div>
        <ul class="Blog_ul2">
          <li><input type="button" value="加关注" id="ConcernBtn" onclick="showErrorMsg(&#39;操作失败,您需要先登录!&#39;, &#39;消息提示&#39;, &#39;/site/login.html&#39;)"></li>
          <li><input type="button" value="短消息" id="postMessageBtn" onclick="showErrorMsg(&#39;操作失败,您需要先登录!&#39;, &#39;消息提示&#39;, &#39;/site/login.html&#39;)"></li>
          <li><input type="button" value="论坛" onclick="location.href=&#39;http://bbs.chinaunix.net&#39;"></li>
          <li><input type="button" value="加好友" id="addFriendBtn" onclick="showErrorMsg(&#39;操作失败,您需要先登录!&#39;, &#39;消息提示&#39;, &#39;/site/login.html&#39;)"></li>
        </ul>
              </div>
        
         
      <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">文章分类</div>
        <div class="Blog_left2_1">
          <p class="Blog_p4"><a href="http://blog.chinaunix.net/uid/26384989/list/1.html">全部博文</a>（80）</p>
          <ul id="blogCla">
                            <li><a href="http://blog.chinaunix.net/uid/26384989/cid--1-list-1.html" title="未分配的博文">未分配的博文</a>（80）
                                </li>
                      </ul>
        </div>
      </div>
      	              <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">文章存档</div>
        <div class="Blog_left2_1" id="blogdtr">
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="http://blog.chinaunix.net/uid/26384989/year-2017-list-1.html">2017年</a>（1）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201701-list-1.html">2017年01月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="http://blog.chinaunix.net/uid/26384989/year-2016-list-1.html">2016年</a>（5）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201612-list-1.html">2016年12月</a>（4）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201601-list-1.html">2016年01月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="http://blog.chinaunix.net/uid/26384989/year-2015-list-1.html">2015年</a>（23）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201509-list-1.html">2015年09月</a>（1）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201506-list-1.html">2015年06月</a>（3）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201504-list-1.html">2015年04月</a>（6）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201503-list-1.html">2015年03月</a>（5）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201501-list-1.html">2015年01月</a>（8）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="http://blog.chinaunix.net/uid/26384989/year-2014-list-1.html">2014年</a>（51）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201412-list-1.html">2014年12月</a>（14）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201411-list-1.html">2014年11月</a>（5）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201409-list-1.html">2014年09月</a>（2）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201408-list-1.html">2014年08月</a>（6）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201407-list-1.html">2014年07月</a>（6）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201406-list-1.html">2014年06月</a>（4）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201405-list-1.html">2014年05月</a>（2）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201403-list-1.html">2014年03月</a>（3）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201402-list-1.html">2014年02月</a>（7）</li>
                        <li><a href="http://blog.chinaunix.net/uid/26384989/year-201401-list-1.html">2014年01月</a>（2）</li>
                      </ul>
                  </div>
      </div>
      	  	        <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">我的朋友</div>
        <ul class="Blog_ul4">
                  </ul>
      </div>
	  	        <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">最近访客</div>
        <ul class="Blog_ul4">
                    <li><a href="http://blog.chinaunix.net/uid/31427953.html">              <img src="http://passport.ixpub.net/avatar.php?uid=31427953&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/31427953.html" title="勒布朗丶詹姆斯">勒布朗丶</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/31424422.html">              <img src="http://passport.ixpub.net/avatar.php?uid=31424422&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/31424422.html" title="Yu_余先生">Yu_余先</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/20590409.html">              <img src="http://passport.ixpub.net/avatar.php?uid=20590409&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/20590409.html" title="jamesjjngu">jamesjjn</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/20150195.html">              <img src="http://passport.ixpub.net/avatar.php?uid=20150195&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/20150195.html" title="laosui">laosui</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/31415216.html">              <img src="http://passport.ixpub.net/avatar.php?uid=31415216&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/31415216.html" title="chinaitboy">chinaitb</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/9535910.html">              <img src="http://passport.ixpub.net/avatar.php?uid=9535910&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/9535910.html" title="morganhan">morganha</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/30204791.html">              <img src="http://passport.ixpub.net/avatar.php?uid=30204791&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/30204791.html" title="王楠w_n">王楠w_n</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/31412425.html">              <img src="http://passport.ixpub.net/avatar.php?uid=31412425&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/31412425.html" title="lkm1248">lkm1248</a></p>
          </li>
                    <li><a href="http://blog.chinaunix.net/uid/30902217.html">              <img src="http://passport.ixpub.net/avatar.php?uid=30902217&amp;size=small">
              </a>
            <p><a href="http://blog.chinaunix.net/uid/30902217.html" title="HazeC">HazeC</a></p>
          </li>
                  </ul>
      </div>
	           <div class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">微信关注</div>
        <div class="">
                <div class="" style="float:left; margin-right:5px;">
                 <img width="90" height="90" alt="" src="http://blog.chinaunix.net/image/IT168.jpg">
                 </div><br>
                <div class="" style="margin-top:10px;">
                 <p class="">
                         IT168企业级官微
                </p>
                 <p class="">

                 <br><br>
                 微信号：IT168qiye
                </p>
                </div>
        </div>
<hr size="1" style="clear:both;">
        <div class="" style="clear:both;">
                <div class="" style="float:left; margin-right:5px;">
                 <img width="90" height="90" alt="" src="http://blog.chinaunix.net/image/itpub.jpg">
                 </div><br>
                <div class="" style="margin-top:10px;">
                 <p class="">
                         系统架构师大会
                </p>
                 <p class="">

                 <br><br>
                 微信号：SACC2013
                </p>
                </div>
        </div>

</div>
      <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">订阅</div>
        <ul class="Blog_ul5">
          <li><a href="http://blog.chinaunix.net/blog/rss/uid/26384989.html" class="Blog_a4"></a></li>
          <li><a href="http://www.google.com/ig/add?feedurl=http%3A%2F%2Fblog.chinaunix.net%2Fuid%2F26384989.html" class="Blog_a5"></a></li>
        </ul>
      </div>
      <div class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">推荐博文</div>
        <ul class="Blog_ul6">
				  			<li>・<a href="http://blog.chinaunix.net/uid-28549627-id-5758547.html" title="nagios分组出图代码实现讲解[2]">nagios分组出图代码实现讲解[...</a></li>
		  			<li>・<a href="http://blog.chinaunix.net/uid-7270462-id-5758498.html" title="Postgresql通过td_fdw连接查询 MS SQL Serever 2008 表">Postgresql通过td_fdw连接查...</a></li>
		  			<li>・<a href="http://blog.chinaunix.net/uid-31385748-id-5758486.html" title="再谈互斥锁与条件变量！（终于搞清楚了啊！！！！！）">再谈互斥锁与条件变量！（终...</a></li>
		  			<li>・<a href="http://blog.chinaunix.net/uid-20726500-id-5758450.html" title="基于Pacemaker的PostgreSQL一主多从读负载均衡集群搭建">基于Pacemaker的PostgreSQL一...</a></li>
		  			<li>・<a href="http://blog.chinaunix.net/uid-15866552-id-5758426.html" title="网站访问量和服务器带宽的选择">网站访问量和服务器带宽的选...</a></li>
		  						
        </ul>
      </div>
      <div class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">热词专题</div>
        <ul class="Blog_ul6">
                        <li>・<a href="http://blog.chinaunix.net/zt/1000/linux_1000000.shtml" target="blank" title="lua编译(linux)">lua编译(linux)</a></li>
                        <li>・<a href="http://blog.chinaunix.net/zt/1000/linuxarmg_1000001.shtml" target="blank" title="linux+ARM学习路线">linux+ARM学习路线</a></li>
                        <li class="no_line1">・<a href="http://blog.chinaunix.net/zt/1062/fl2440hjtagcantdownloaddrivertospeci_1062900.shtml" target="blank" title="driver">driver</a></li>
          <!--              <li>・<a href="http://www.dataguru.cn/zhuanti/hadoop220peizhi.shtml" target='blank' title='配置hadoop2.2.0格式化namenode问题'></a></li>
              <li>・<a href="http://www.dataguru.cn/zhuanti/hadoopshouce.shtml" target='blank' title='hadoop2.2.0安装手册'></a></li>-->
        </ul>
      </div>
	  

	</div>
    <!-- 右 -->
    <div class="Blog_right1">
      <div class="Blog_right1_1 Blog_right1_11">
        <div class="Blog_right1_2 ">
			<!--推荐博文-->
          <div class="Blog_tit4 Blog_tit5">
                        <b class="Blog_b2"></b>
            <a name="baidusnap0"></a><a href="http://blog.chinaunix.net/uid-26384989-id-4703946.html"><b style="color:black;background-color:#ffff66">嵌入式工程师笔试面试题目</b></a>
            <em>2014<b style="color:white;background-color:#886800">-</b>12<b style="color:white;background-color:#886800">-</b>18 14:39:03</em>
          </div>
          <div class="Blog_con2">
            <div class="Blog_con3">
              <p>分类： <span>C/C++</span></p>
			                <p>原文地址：<span><a href="http://blog.chinaunix.net/uid-24958038-id-3135809.html"><b style="color:black;background-color:#ffff66">嵌入式工程师笔试面试题目</b></a></span> 作者：<span><a href="http://blog.chinaunix.net/uid/24958038.html">kinghannah</a></span></p>
			                <p></p>
            </div>
           <div class="Blog_wz1" style="word-wrap: break-word;">
						<div>7.C++中为什么用模板类。<br>答：(1)可用来创建动态增长和减小的数据结构<br>（2）它是类型无关的，因此具有很高的可复用性。<br>（3）它在编译时而不是运行时检查数据类型，保证了类型安全<br>（4）它是平台无关的，可移植性<br>（5）可用于基本数据类型<br>8.CSingleLock是干什么的。<br>答：同步多个线程对一个数据类的同时访问<br>12.Linux有内核级线程么。<br>答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两<br>种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序<br>中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度<br>和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现<br>，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一<br>种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部<br>需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支<br>，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线<br>程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不<br>到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占<br>用了更多的系统开支。 <br>Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程<br>14.使用线程是如何防止出现大的波峰。<br>答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提<br>高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队<br>等候<br>15函数模板与类模板有什么区别？<br>答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化<br>必须由程序员在程序中显式地指定。
<p>22.TCP/IP 建立连接的过程?(3<b style="color:white;background-color:#886800">-</b>way shake)<br>答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>　　第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状<br>态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个<br>SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>　　第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)<br>，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>23.ICMP是什么协议,处于哪一层?<br>答：Internet控制报文协议，处于网络层（IP层<br>27.IP组播有那些好处?<br>答：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧<br>消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包<br>到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无<br>论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播<br>技术的核心就是针对如何节约网络资源的前提下保证服务质量。<br>2.引用与指针有什么区别？<br>&nbsp;&nbsp;&nbsp; 1) 引用必须被初始化，指针不必。<br>&nbsp;&nbsp;&nbsp; 2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>&nbsp;&nbsp;&nbsp; 3) 不存在指向空值的引用，但是存在指向空值的指针。 <br>4.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 全局变量储存在静态数据库，局部变量在堆栈。<br>5.什么是平衡二叉树？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。<br>6.堆栈溢出一般是由什么原因导致的？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有回收垃圾资源。内存泄露<br>8.冒泡排序算法的时间复杂度是什么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 时间复杂度是O(n^2)。 <br>9.写出float x 与“零值”比较的if语句。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(x&gt;0.000001&amp;&amp;x&lt;<b style="color:white;background-color:#886800">-</b>0.000001) 软件开发网 </p>
<p>. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</p>
<p>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<br>我在这想看到几件事情：<br>1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）<br>2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。<br>3). 意识到这个表达式将使一个16位机的整型数溢出<b style="color:white;background-color:#886800">-</b>因此要用到长整型符号L,告诉编译器这个常数是的长整型数。<br>4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</p>
<p>2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。</p>
<p>#define MIN(A,B) ((A) &lt;= (B) (A) : (B))<br>这个测试是为下面的目的而设的：<br>1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，<br>对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。<br>2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if<b style="color:white;background-color:#886800">-</b>then<b style="color:white;background-color:#886800">-</b>else更优化的代码，了解这个用法是很重要的。<br>3). 懂得在宏中小心地把参数用括号括起来<br>4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？<br>least = MIN(*p++, b);</p>
<p>3. 预处理器标识#error的目的是什么？</p>
<p>如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种<br>问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p>
<p>死循环（Infinite loops）</p>
<p>4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</p>
<p>这个问题用几个解决方案。我首选的方案是：<br>while(1)<br>{<br>}<br>一些程序员更喜欢如下方案：<br>for(;;)<br>{<br>}<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>...<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p>
<p>数据声明（Data declarations）</p>
<p>5. 用变量a给出下面的定义<br>a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）</p>
<p>答案是：<br>a) int a; // An integer<br>b) int *a; // A pointer to an integer<br>c) int **a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int *a[10]; // An array of 10 pointers to integers<br>f) int (*a)[10]; // A pointer to an array of 10 integers<br>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>
<p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。<br>但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道<br>所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？</p>
<p>Static</p>
<p>6. 关键字static的作用是什么？</p>
<p>这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数<br>据和代码范围的好处和重要性。</p>
<p>Const</p>
<p>7．关键字const是什么含意？<br>我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？</p>
<p>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>int const * a const;</p>
<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：<br>1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。<br>3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>
<p>Volatile</p>
<p>8. 关键字volatile有什么含意 并给出三个不同的例子。</p>
<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non<b style="color:white;background-color:#886800">-</b>automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br>int square(volatile int *ptr)<br>{<br>return *ptr * *ptr;<br>}<br>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：<br>int square(volatile int *ptr)<br>{<br>int a,b;<br>a = *ptr;<br>b = *ptr;<br>return a * b;<br>}<br>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：<br>long square(volatile int *ptr)<br>{<br>int a;<br>a = *ptr;<br>return a * a;<br>}</p>
<p>位操作（Bit manipulation）</p>
<p>9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。</p>
<p>对这个问题有三种基本的反应<br>1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：<br>#define BIT3 (0x1&lt;&lt;3)<br>static int a;<br>void set_bit3(void)<br>{<br>a |= BIT3;<br>}<br>void clear_bit3(void)<br>{<br>a &amp;= ~BIT3;<br>}<br>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。</p>
<p>访问固定的内存位置（Accessing fixed memory locations）</p>
<p>10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。</p>
<p>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：<br>int *ptr;<br>ptr = (int *)0x67a9;<br>*ptr = 0xaa55;</p>
<p>一个较晦涩的方法是：<br>*(int * const)(0x67a9) = 0xaa55;</p>
<p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p>
<p>中断（Interrupts）</p>
<p>11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展―让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。</p>
<p>__interrupt double compute_area (double radius)<br>{<br>double area = PI * radius * radius;<br>printf(" Area = %f", area);<br>return area;<br>}</p>
<p>这个函数有太多的错误了，以至让人不知从何说起了：<br>1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p>
<p>代码例子（Code examples）</p>
<p>12 . 下面的代码输出是什么，为什么？</p>
<p>void foo(void)<br>{<br>unsigned int a = 6;<br>int b = <b style="color:white;background-color:#886800">-</b>20;<br>(a+b &gt; 6) puts("&gt; 6") : puts("&lt;= 6");<br>}</p>
<p><br>这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此<b style="color:white;background-color:#886800">-</b>20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p>
<p>13. 评价下面的代码片断：</p>
<p>unsigned int zero = 0;<br>unsigned int compzero = 0xFFFF;<br>/*1's complement of zero */</p>
<p>对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：</p>
<p>unsigned int compzero = ~0;</p>
<p>这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。<br>到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…</p>
<p>动态内存分配（Dynamic memory allocation）</p>
<p>14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？</p>
<p>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？</p>
<p>char *ptr;<br>if ((ptr = (char *)malloc(0)) == NULL)<br>puts("Got a null pointer");<br>else<br>puts("Got a valid pointer");</p>
<p>这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p>
<p>Typedef</p>
<p>15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：<br>#define dPS struct s *<br>typedef struct s * tPS;</p>
<p>以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？</p>
<p>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：<br>dPS p1,p2;<br>tPS p3,p4;</p>
<p>第一个扩展为<br>struct s * p1, p2;</p>
<p>上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。</p>
<p>晦涩的语法</p>
<p>16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<br>int a = 5, b = 7, c;<br>c = a+++b;</p>
<p>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：<br>c = a++ + b;<br>因此, 这段代码持行后a = 6, b = 7, c = 12。<br>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题<br>系统分类: 嵌入式系统&nbsp;&nbsp; |&nbsp;&nbsp; 用户分类: 技术分享&nbsp;&nbsp; |&nbsp;&nbsp; 来源: 整理 <br>&nbsp;&nbsp;&nbsp; 阅读(95)&nbsp;&nbsp;&nbsp; 回复(1)&nbsp;&nbsp; </p>
<p>3、用递归算法判断数组a[N]是否为一个递增数组。<br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false结束：<br>bool fun( int a[], int n )<br>{<br>if( n= =1 )<br>return true;<br>if( n= =2 )<br>return a[n<b style="color:white;background-color:#886800">-</b>1] &gt;= a[n<b style="color:white;background-color:#886800">-</b>2];<br>return fun( a,n<b style="color:white;background-color:#886800">-</b>1) &amp;&amp; ( a[n<b style="color:white;background-color:#886800">-</b>1] &gt;= a[n<b style="color:white;background-color:#886800">-</b>2] );<br>}<br>4、编写算法，从10亿个浮点数当中，选出其中最大的10000个。<br>用外部排序，在《数据结构》书上有<br>《计算方法导论》在找到第n大的数的算法上加工<br>5、编写一unix程序，防止僵尸进程的出现.</p>
<p>2.单连表的建立，把'a'<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>'z'26个字母插入到连表中，并且倒叙，还要打印！<br>方法1：<br>typedef struct val<br>{&nbsp;&nbsp;&nbsp; int date_1;<br>&nbsp;&nbsp;&nbsp;&nbsp; struct val *next;<br>}*p;<br>void main(void)<br>{&nbsp;&nbsp;&nbsp; char c;<br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; for(c=122;c&gt;=97;c<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { p.date=c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p="p<b style="color:white;background-color:#886800">-</b>"&gt;next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; p.next=NULL;<br>} <br>}<br>方法2：<br>node *p = NULL;<br>node *q = NULL;<br>node *head = (node*)malloc(sizeof(node));<br>head<b style="color:white;background-color:#886800">-</b>&gt;data = ' ';head<b style="color:white;background-color:#886800">-</b>&gt;next=NULL;<br>node *first = (node*)malloc(sizeof(node));<br>first<b style="color:white;background-color:#886800">-</b>&gt;data = 'a';first<b style="color:white;background-color:#886800">-</b>&gt;next=NULL;head<b style="color:white;background-color:#886800">-</b>&gt;next = first;<br>p = first;<br>int longth = 'z' <b style="color:white;background-color:#886800">-</b> 'b';<br>int i="0";<br>while ( i&lt;=longth )<br>{<br>node *temp = (node*)malloc(sizeof(node));<br>temp<b style="color:white;background-color:#886800">-</b>&gt;data = 'b'+i;temp<b style="color:white;background-color:#886800">-</b>&gt;next=NULL;q=temp;<br>head<b style="color:white;background-color:#886800">-</b>&gt;next = temp; temp<b style="color:white;background-color:#886800">-</b>&gt;next=p;p=q;<br>i++;<br>}<br>print(head);<br>&nbsp;<br>测试程序<br>#include <stdio.h><br>struct A{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>};</stdio.h></p>
<p>struct B{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>}__attribute__((aligned));</p>
<p>struct C{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>}__attribute__((aligned(1)));</p>
<p><br>struct D{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>}__attribute__((aligned(4)));</p>
<p>struct E{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>}__attribute__((aligned(8)));</p>
<p>struct F{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short c;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long d;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char f;<br>}__attribute__((packed));</p>
<p>int main(int argc, char **argv)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("A = %d, B = %d, C = %d, D = %d, E = %d, F = %d/n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct A), sizeof(struct B), sizeof(struct C), sizeof(struct D), sizeof(struct E), sizeof(struct F));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>}<br>在fedora 7下的测试结果：<br>A = 28, B = 32, C = 28, D = 28, E = 32, F = 20<br>A：不使用__attribute__ 默认4字节对齐<br>B：__attribute__((aligned)) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the compiler automatically sets the alignment for the declared variable or field to the largest alignment which is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way.<br>&nbsp;&nbsp; 最大对齐方式，此例中为16字节对齐，同E<br>C:__attribute__((aligned(1))) 不支持，除了packed 不能减小对齐字节数，以默认对齐方式对齐<br>D:__attribute__((aligned(4))) 四字节对齐<br>E：__attribute__((aligned(8))) 八字节对齐<br>F：__attribute__((packed)) <br>&nbsp;&nbsp;&nbsp;&nbsp; the aligned attribute can only increase the alignment; but you can decrease it by specifying packed as well. <br>&nbsp;&nbsp;&nbsp;&nbsp; The packed attribute specifies that a variable or structure field should have the smallest possible alignmentDone byte for a variable, and one bit for a field, unless you specify a larger value with the aligned attribute. <br>Here is a structure in which the field x is packed, so that it immediately follows a: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct foo<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x[2] __attribute__ ((packed));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp; 变量以字节对齐，结构体域以位对齐&nbsp;&nbsp; <br>cygwin下的测试结果：<br>A = 32, B = 32, C = 32, D = 32, E = 32, F = 20<br>从测试结果上看默认8字节对齐？或是只支持packed,未知<br>可参考的文档：<br><a href="http://developer.apple.com/documentation/DeveloperTools/gcc-3.3/gcc/Variable-Attributes.html" target="_blank">http://developer.apple.com/documentation/DeveloperTools/gcc<b style="color:white;background-color:#886800">-</b>3.3/gcc/Variable<b style="color:white;background-color:#886800">-</b>Attributes.html</a><br><a href="http://www.skynet.org.cn/archiver/?tid-87.html" target="_blank">http://www.skynet.org.cn/archiver/?tid<b style="color:white;background-color:#886800">-</b>87.html</a><br>编程题</p>
<p>一个递规反向输出字符串的例子,可谓是反序的经典例程.<br>void inverse(char *p)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp; if( *p = = '/0' ) <br>return;<br>&nbsp;&nbsp;&nbsp;&nbsp; inverse( p+1 );<br>&nbsp;&nbsp;&nbsp;&nbsp; printf( "%c", *p );<br>}<br>int main(int argc, char *argv[])<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp; inverse("abc/0");<br>&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>}</p>
<p>3。输出和为一个给定整数的所有组合<br>例如n=5<br>5=1+4；5=2+3（相加的数不能重复）<br>则输出<br>1，4；2，3。<br>答案：<br>＃i nclude <stdio.h><br>&nbsp;＃i nclude <stdio.h><br>void main()<br>{<br>unsigned long int a,i=1;<br>scanf("%d",&amp;a);<br>if(a%2==0)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=1;i<a 2;i++)<br="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d",a,a<b style="color:white;background-color:#886800">-</b>i);<br>}<br>else<br>for(i=1;i&lt;=a/2;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(" %d, %d",i,a<b style="color:white;background-color:#886800">-</b>i);<br>}</a></stdio.h></stdio.h></p><a 2;i++)<br="">
<p>4。在对齐为4的情况下<br>struct BBB<br>{<br>&nbsp;&nbsp;&nbsp; long num；<br>&nbsp;&nbsp;&nbsp; char *name;<br>&nbsp;&nbsp;&nbsp; short int data;<br>&nbsp;&nbsp;&nbsp; char ha;<br>&nbsp;&nbsp;&nbsp; short ba[5];<br>}*p;<br>p=0x1000000;<br>p+0x200=____;<br>(Ulong)p+0x200=____;<br>(char*)p+0x200=____;<br>答案：假设在32位CPU上，<br>sizeof(long) = 4 bytes<br>sizeof(char *) = 4 bytes<br>sizeof(short int) = sizeof(short) = 2 bytes<br>sizeof(char) = 1 bytes</p>
<p>由于是4字节对齐，<br>sizeof(struct BBB) = sizeof(*p) <br>= 4 + 4 + 4(（2 + 1 ）+ 1补齐为4）+ 12(2*5 + 2补齐为12) = 24 bytes&nbsp; <br>p=0x1000000;<br>p+0x200=____;<br>&nbsp;&nbsp;&nbsp;&nbsp; = 0x1000000 + 0x200*24<br>(Ulong)p+0x200=____;<br>&nbsp;&nbsp;&nbsp;&nbsp; = 0x1000000 + 0x200<br>(char*)p+0x200=____;<br>&nbsp;&nbsp;&nbsp;&nbsp; = 0x1000000 + 0x200*4</p>
<p>5。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。函数接口为：int find_orderk(const int* narry,const int n,const int k) <br>要求算法复杂度不能是O(n^2）</p>
<p>答案：可以先用快速排序进行排序，其中用另外一个进行地址查找<br>代码如下，在VC++6.0运行通过。给分吧^<b style="color:white;background-color:#886800">-</b>^<br>//快速排序<br>＃i nclude<iostream><br>usingnamespacestd;<br>intPartition (int*L,intlow,int high)<br>{<br>inttemp = L[low];<br>intpt = L[low];<br>while (low &lt; high)<br>{<br>while (low &lt; high &amp;&amp; L[high] &gt;= pt)<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>high;<br>L[low] = L[high];<br>while (low &lt; high &amp;&amp; L[low] &lt;= pt)<br>++low;<br>L[low] = temp;<br>}<br>L[low] = temp;<br>returnlow;<br>}<br>voidQSort (int*L,intlow,int high)<br>{<br>if (low &lt; high)<br>{<br>intpl = Partition (L,low,high);<br>QSort (L,low,pl <b style="color:white;background-color:#886800">-</b> 1);<br>QSort (L,pl + 1,high);<br>}<br>}<br>intmain ()<br>{<br>intnarry[100],addr[100];<br>intsum = 1,t;<br>cout &lt;&lt; "Input number:" &lt;&lt; endl;<br>cin &gt;&gt; t;<br>while (t != <b style="color:white;background-color:#886800">-</b>1)<br>{<br>narry[sum] = t;<br>addr[sum <b style="color:white;background-color:#886800">-</b> 1] = t;<br>sum++;<br>cin &gt;&gt; t;<br>}<br>sum <b style="color:white;background-color:#886800">-</b>= 1;<br>QSort (narry,1,sum);<br>for (int i = 1; i &lt;= sum;i++)<br>cout &lt;&lt; narry[i] &lt;&lt; '/t';<br>cout &lt;&lt; endl;<br>intk;<br>cout &lt;&lt; "Please input place you want:" &lt;&lt; endl;<br>cin &gt;&gt; k;<br>intaa = 1;<br>intkk = 0;<br>for (;;)<br>{<br>if (aa == k)<br>break;<br>if (narry[kk] != narry[kk + 1])<br>{<br>aa += 1;<br>kk++;<br>}<br>}<br>cout &lt;&lt; "The NO." &lt;&lt; k &lt;&lt; "number is:" &lt;&lt; narry[sum <b style="color:white;background-color:#886800">-</b> kk] &lt;&lt; endl;<br>cout &lt;&lt; "And it's place is:" ;<br>for (i = 0;i &lt; sum;i++)<br>{<br>if (addr[i] == narry[sum <b style="color:white;background-color:#886800">-</b> kk])<br>cout &lt;&lt; i &lt;&lt; '/t';<br>}</iostream></p>
<p>return0;<br>}</p>
<p>int main(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int MAX = 10;<br>int *a = (int *)malloc(MAX * sizeof(int));<br>int *b;<br>&nbsp;&nbsp;&nbsp; <br>FILE *fp1;<br>FILE *fp2;<br>fp1 = fopen("a.txt","r");<br>if(fp1 == NULL)<br>{printf("error1");<br>&nbsp;&nbsp;&nbsp;&nbsp; exit(<b style="color:white;background-color:#886800">-</b>1);<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp; fp2 = fopen("b.txt","w");<br>if(fp2 == NULL)<br>{printf("error2");<br>&nbsp;&nbsp;&nbsp;&nbsp; exit(<b style="color:white;background-color:#886800">-</b>1);<br>}<br>int i = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp; int j = 0;<br>while(fscanf(fp1,"%d",&amp;a[i]) != EOF)<br>{<br>i++;<br>j++;<br>if(i &gt;= MAX)<br>{<br>MAX = 2 * MAX;<br>b = (int*)realloc(a,MAX * sizeof(int));<br>if(b == NULL)<br>{<br>printf("error3");<br>exit(<b style="color:white;background-color:#886800">-</b>1);<br>}<br>a = b;<br>}<br>}<br>for(;<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>j &gt;= 0;)<br>&nbsp;&nbsp;&nbsp; fprintf(fp2,"%d/n",a[j]);<br>fclose(fp1);<br>fclose(fp2);<br>return 0;<br>}</p>
<p>2。运行的结果为什么等于15<br>＃i nclude "stdio.h"<br>＃i nclude "string.h"<br>void main()<br>{<br>char aa[10];<br>printf("%d",strlen(aa));<br>}<br>答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。</p>
<p>4。分析一下<br>＃i nclude<iostream.h><br>＃i nclude <string.h><br>＃i nclude <malloc.h><br>＃i nclude <stdio.h><br>＃i nclude <stdlib.h><br>＃i nclude <memory.h><br>typedef struct&nbsp;&nbsp; AA<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b1:5;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b2:2;<br>}AA;<br>void main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AA aa;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char cc[100];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(&amp;aa,cc,sizeof(AA));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; aa.b1 &lt;<endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; aa.b2 &lt;<endl;<br>}</endl;<br></endl;<br></memory.h></stdlib.h></stdio.h></malloc.h></string.h></iostream.h></p>
<p>答案： <b style="color:white;background-color:#886800">-</b>16和１<br>首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.<br>经过strcpy和memcpy后,aa的4个字节所存放的值是:<br>0,1,2,3的ASC码，即00110000,00110001,00110010,00110011<br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br>分别为：10000,和01<br>因为int是有正负之分,所以是<b style="color:white;background-color:#886800">-</b>16和１<br>5。求函数返回值，输入x=9999; <br>int func （ x ）<br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp; int countx = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp; while ( x ) <br>&nbsp;&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countx ++; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x&amp;(x<b style="color:white;background-color:#886800">-</b>1); <br>&nbsp;&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp;&nbsp; return countx; <br>} <br>结果呢？</p>
</a><p><a 2;i++)<br="">答案：知道了这是统计9999的二进制数值中有多少个1的函数，且有<br>9999＝9×1024＋512＋256＋15<br>9×1024中含有1的个数为2；<br>512中含有1的个数为1；<br>256中含有1的个数为1；<br>15中含有1的个数为4；<br>故共有1的个数为8，结果为8。<br>1000 <b style="color:white;background-color:#886800">-</b> 1 = 0111，正好是原数取反。这就是原理。<br>用这种方法来求1的个数是很效率很高的。<br>不必去一个一个地移位。循环次数最少。<br>6。int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题<br>答案：bool add (int a, int b,int *c)<br>{<br>*c=a+b;<br>return (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp;(*c</a><a ||="" *c<b)="" (a<0="" &&="" b<0="" &&(*c="">a || *c&gt;b)));<br>}</a></p><a ||="" *c<b)="" (a<0="" &&="" b<0="" &&(*c="">
<p>8。改错：<br>＃i nclude <stdio.h><br>int main(void) {<br>&nbsp;&nbsp;&nbsp;&nbsp; int **p;<br>&nbsp;&nbsp;&nbsp;&nbsp; int arr[100];<br>&nbsp;&nbsp;&nbsp;&nbsp; p = &amp;arr;<br>&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>}<br>答案：搞错了,是指针类型不同,<br>int **p; //二级指针<br>&amp;arr; //得到的是指向第一维为100的数组的指针<br>应该这样写＃i nclude <stdio.h><br>int main(void) {<br>int **p, *q;<br>int arr[100];<br>q = arr;<br>p = &amp;q;<br>return 0;<br>标准答案示例：<br>const float EPSINON = 0.00001;<br>if ((x &gt;= <b style="color:white;background-color:#886800">-</b> EPSINON) &amp;&amp; (x &lt;= EPSINON)</stdio.h></stdio.h></p>
<p>void *p = malloc( 100 );<br>请计算<br>sizeof ( p ) =&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2分）</p>
<p>4、在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”？ （5分）<br>答：C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为： void foo(int x, int y);<br>该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。<br>C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>1.说出下面这个程序的运行结果，并简要叙述其理由：<br>char buf1[10]="hello";<br>char buf2[10]="hello";<br>if (buf1==buf2)<br>printf("equal!");<br>else printf("not equal!");<br>因为buf1,buf2分配了不同的内存块，而比较的是数组名，实际上是两个分别指向数组起始元素地址的指针。</p>
<p>类string的构造函数<br>string::string(const char* str)<br>{<br>&nbsp;&nbsp; if(str == NULL)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_data = new char[1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *m_data = '/0';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int length = strlen(str);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_data = new char[str + 1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(m_data, str);<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>}<br>string 的析构函数<br>string::~string()<br>{<br>&nbsp;&nbsp; delete [] m_data;<br>}<br>string 的拷贝构造函数<br>string ::string(const string&amp; other)<br>{<br>&nbsp;&nbsp; int len = strlen(other.m_data);<br>&nbsp;&nbsp; m_data = new char[len + 1];<br>&nbsp;&nbsp; strcpy(m_data, other.m_data);<br>}<br>string 的赋值函数<br>string&amp; string::operator=(const string&amp; other)<br>{<br>&nbsp;&nbsp; if (this == &amp;other)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;<br>&nbsp;&nbsp; delete [] m_data;<br>&nbsp;&nbsp; int len = strlen(other.m_data);<br>&nbsp;&nbsp; m_data = new char[len + 1];<br>&nbsp;&nbsp; strcpy(m_data, other.m_data);<br>&nbsp;&nbsp; return *this;<br>}&nbsp;&nbsp; </p>
<p>不用任何局部和全局变量实现int strlen(char *a) <br>int strlen(char *a) {<br>&nbsp;&nbsp;&nbsp; if('/0' == *a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1 + strlen(a + 1);<br>}</p>
<p><br>1)求出相似度的算法.<br>2)写出二分查找的代码.<br>int binary_search(int* arr, int key, int n)<br>{<br>&nbsp;&nbsp; int low = 0;<br>&nbsp;&nbsp; int high = n <b style="color:white;background-color:#886800">-</b> 1;<br>&nbsp;&nbsp; int mid;<br>&nbsp;&nbsp; while (low &lt;= high)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (high + low) / 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arr[mid] &gt; k)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; high = mid <b style="color:white;background-color:#886800">-</b> 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (arr[mid] &lt; k)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; low = mid + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return mid;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return <b style="color:white;background-color:#886800">-</b>1;<br>}<br>&nbsp; <br>*6)实现strcpy函数<br>char* strcpy(char* dest, const char* src)<br>{<br>&nbsp;&nbsp; assert((dest != NULL) &amp;&amp; (src != NULL));<br>&nbsp;&nbsp; char* address = dest;<br>&nbsp;&nbsp; while ('/0' != (*dest++ = *src++));<br>&nbsp;&nbsp; return address;<br>}<br>出现次数相当频繁</p>
<p>*10)将一个数字字符串转换为数字."1234" <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt;1234<br>#include<iostream><br>using namespace std;<br>int f(char* s)<br>{<br>&nbsp;&nbsp; int k = 0;<br>&nbsp;&nbsp; while (*s)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 10 * k + (*s++)<b style="color:white;background-color:#886800">-</b> '0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; } <br>&nbsp;&nbsp; return k;<br>}<br>int main()<br>{<br>&nbsp;&nbsp; int digit = f("4567");<br>&nbsp;&nbsp; cout&lt;<digit<<endl;<br>&nbsp;&nbsp; cin.get();<br>}<br>出现次数相当频繁</digit<<endl;<br></iostream></p>
<p>11)实现任意长度的整数相加或者相乘功能。<br>*12)写函数完成内存的拷贝<br>一个内存拷贝函数的实现体<br>void *memcpy(void *pvTo,const void *pvFrom,size_t size)<br>{<br>assert((pvTo!=NULL)&amp;&amp;(pvFrom!=NULL));<br>byte *pbTo=(byte*)pvTo; //防止地址被改变<br>byte *pbFrom=(byte*)pvFrom;<br>while (size<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b> &gt;0)<br>*pbTo++ = *pbForm++;<br>return pvTo;<br>} <br>出现次数相当频繁<br>&nbsp;</p>
<p>.笔试: <br>1)写一个内存拷贝函数,不用任何库函数.就是前些时候本版讨论的那个问题.<br>&nbsp;void* memcpy(void* pvTo, const void* pvFrom, size_t size)<br>&nbsp;{<br>&nbsp;&nbsp;&nbsp; assert((pvTo != NULL) &amp;&amp; (pvFrom != NULL));<br>&nbsp;&nbsp;&nbsp; byte* pbTo = pvTo;<br>&nbsp;&nbsp;&nbsp; byte* pbFrom = pbFrom;<br>&nbsp;&nbsp;&nbsp; while (size<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b> &gt; 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pbTo++ = *pbFrom++;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return pvTo;<br>&nbsp;}<br>2)将一个单链表逆序.(这个问题是个常规的数据结构问题.不过不小心时会损失效率) <br>3)客房预定的问题.根据客户报的人数,客房等级来从预备的客房中选择出所有符合要求的 <br>客房号.客户没有要求等级时,只考虑人数因素就可以了.要考虑有些客房已经预定的情况. <br>(写代码是要考虑好彼此的效率) <br>4)对于一个无序序列进行二分查找 <br>线排序再查找<br>5)将一个数字字符串转换为数字."1234" <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt;1234<br>int convert(char* str)<br>{<br>&nbsp;&nbsp; int k = 0;<br>&nbsp;&nbsp; while (*str != '/0')<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = k * 10 + *s++ <b style="color:white;background-color:#886800">-</b> '0';<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return k;<br>} </p>
<p>四、有关内存的思考题（每小题5分，共20分）<br>void GetMemory(char *p)<br>{<br>p = (char *)malloc(100);<br>}<br>void Test(void) <br>{<br>char *str = NULL;<br>GetMemory(str);&nbsp;<br>strcpy(str, "hello world");<br>printf(str);<br>}<br>请问运行Test函数会有什么样的结果？<br>答：试题传入GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完<br>char *str = NULL; <br>GetMemory( str ); <br>后的str仍然为NULL；<br>&nbsp;<br>&nbsp;&nbsp;char *GetMemory(void)<br>{&nbsp;<br>char p[] = "hello world";<br>return p;<br>}<br>void Test(void)<br>{<br>char *str = NULL;<br>str = GetMemory();&nbsp;<br>printf(str);<br>}<br>请问运行Test函数会有什么样的结果？<br>答：可能是乱码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char p[] = "hello world";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp; return p;&nbsp; <br>的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。<br>&nbsp;<br>void GetMemory2(char **p, int num)<br>{<br>*p = (char *)malloc(num);<br>}<br>void Test(void)<br>{<br>char *str = NULL;<br>GetMemory(&amp;str, 100);<br>strcpy(str, "hello");&nbsp;<br>printf(str);&nbsp;<br>}<br>请问运行Test函数会有什么样的结果？<br>答：<br>（1）能够输出hello<br>（2 ）Test函数中也未对malloc的内存进行释放。<br>（3）GetMemory避免了试题1的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句<br>*p = (char *) malloc( num ); <br>后未判断内存是否申请成功，应加上：<br>if ( *p == NULL ) <br>&nbsp;{ <br>&nbsp;&nbsp; ...//进行申请内存失败处理 <br>　}<br>　<br>&nbsp;<br>&nbsp;&nbsp;void Test(void)<br>{<br>char *str = (char *) malloc(100);<br>&nbsp;strcpy(str, “hello”);<br>&nbsp;free(str);&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;if(str != NULL) <br>&nbsp;{<br>&nbsp;&nbsp; strcpy(str, “world”);&nbsp;<br>printf(str);<br>}<br>}<br>请问运行Test函数会有什么样的结果？<br>答：执行<br>char *str = (char *) malloc(100); <br>后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：<br>str = NULL;<br>&nbsp;<br>&nbsp;</p>
<p><br>2. 写出运行结果<br>#include <stdlib.h><br>#include <stdio.h><br>#include <string.h></string.h></stdio.h></stdlib.h></p>
<p>int main(int argc, char *argv[]) {</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;char a[] = "abc";<br>&nbsp;&nbsp;&nbsp; &nbsp;char b[] = {'d', 'e', 'f'};</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;printf("a slen=%d,b slen=%d/n", strlen(a),strlen(b));<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;printf("a = %s, b = %s/n", a, b);<br>&nbsp;&nbsp;&nbsp; &nbsp;printf("asize len = %d, bsize len = %d/n", sizeof(a),sizeof(b));<br>&nbsp;&nbsp;&nbsp; &nbsp;return 0;</p>
<p>/0<br>c<br>b<br>a<br>f<br>e<br>d</p>
<p>}</p>
<p>a slen = 3,b slen = 6<br>a<br>a = abc, b = defabc<br>asize len = 4, bsize len = 3<br>注：栈分配原则：从高地址<b style="color:white;background-color:#886800">－</b>&gt;低地址分配；<br>b</p>
<p>It is not the above result when I test in Vmware Linux.</p>
</a><p><a ||="" *c<b)="" (a<0="" &&="" b<0="" &&(*c="">4. 说出错误<br>void test() {<br>&nbsp;&nbsp;&nbsp; char str[10];<br>&nbsp;&nbsp;&nbsp; char* str1 = "0123456789";//alloc in the only read data area<br>&nbsp;&nbsp;&nbsp; strcpy(str, str1); //array index overflow<br>&nbsp;Strcpy(str1,str)&nbsp; //because str1 alloced in the only read data area<br>}<br>注：数组越界<br></a><a href="mailto:haiou01@hotmail.com" target="_blank">haiou01@hotmail.com</a><br>5. 说出错误<br>void test() {<br>&nbsp;&nbsp;&nbsp; char str[10], str1[10];<br>&nbsp;&nbsp;&nbsp; for( int = 0; i &lt; 10; i++){ //memset(str,0,sizeof(str))<br>//modif&nbsp; i&lt; 10<b style="color:white;background-color:#886800">-</b>1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str[i] = 'a';<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; strcpy(str1, str);//find not string file end descripe<br>}</p>
<p>8 写出运行结果<br>#include <stdio.h><br>#include <string.h></string.h></stdio.h></p>
<p>#define STRCPY(a, b)&nbsp;&nbsp;&nbsp; strcpy(a##_p, #b)<br>#define STRCPY1(a, b)&nbsp;&nbsp; strcpy(a##_p, b##_p)</p>
<p>int main(void)&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char var1_p[20];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char var2_p[30];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(var1_p, "aaaa");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(var2_p, "bbbb");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRCPY1(var1, var2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRCPY(var2, var1);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("var1 = %s/n", var1_p);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("var2 = %s/n", var2_p);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>}</p>
<p>var1 = bbbb<br>var2 = var1<br>宏中"#"和"##"的用法 </p>
<p>一、一般用法 </p>
<p>我们使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起. <br>用法: <br>#include<cstdio> <br>#include<climits> <br>using namespace std; <br>#define STR(s) #s <br>#define CONS(a,b) int(a##e##b) <br>int main() <br>{ <br>printf(STR(vck)); // 输出字符串"vck" <br>printf("%d/n", CONS(2,3)); // 2e3 输出:2000 <br>return 0; <br>} </climits></cstdio></p>
<p>二、当宏参数是另一个宏的时候 <br>需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开. <br>1, 非'#'和'##'的情况 <br>#define TOW (2) <br>#define MUL(a,b) (a*b) <br>printf("%d*%d=%d/n", TOW, TOW, MUL(TOW,TOW)); <br>这行的宏会被展开为： <br>printf("%d*%d=%d/n", (2), (2), ((2)*(2))); <br>MUL里的参数TOW会被展开为(2). </p>
<p>2, 当有'#'或'##'的时候 <br>#define A (2) <br>#define STR(s) #s <br>#define CONS(a,b) int(a##e##b) <br>printf("int max: %s/n", STR(INT_MAX)); // INT_MAX #include<climits> <br>这行会被展开为： <br>printf("int max: %s/n", "INT_MAX"); </climits></p>
<p>printf("%s/n", CONS(A, A)); // compile error <br>这一行则是： <br>printf("%s/n", int(AeA)); <br>A不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏. <br>加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数. <br>#define A (2) <br>#define _STR(s) #s <br>#define STR(s) _STR(s) // 转换宏 <br>#define _CONS(a,b) int(a##e##b) <br>#define CONS(a,b) _CONS(a,b) // 转换宏 <br>printf("int max: %s/n", STR(INT_MAX)); // INT_MAX,int型的最大值，为一个变量 #include<climits> <br>输出为: int max: 0x7fffffff </climits></p>
<p>STR(INT_MAX) <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; _STR(0x7fffffff) 然后再转换成字符串； <br>printf("%d/n", CONS(A, A)); <br>输出为：200 <br>CONS(A, A) <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; _CONS((2), (2)) <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; int((2)e(2)) </p>
<p>三、'#'和'##'的一些应用特例 <br>1、合并匿名变量名 <br>#define ___ANONYMOUS1(type, var, line) type var##line <br>#define __ANONYMOUS0(type, line) ___ANONYMOUS1(type, _anonymous, line) <br>#define ANONYMOUS(type) __ANONYMOUS0(type, __LINE__) </p>
<p>例：ANONYMOUS(static int); 即: static int _anonymous70; 70表示该行行号； <br>第一层：ANONYMOUS(static int); <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; __ANONYMOUS0(static int, __LINE__); <br>第二层： <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; ___ANONYMOUS1(static int, _anonymous, 70); <br>第三层： <b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; static int _anonymous70; <br>即每次只能解开当前层的宏，所以__LINE__在第二层才能被解开； <br>2、填充结构 <br>#define FILL(a) {a, #a} <br>enum IDD{OPEN, CLOSE}; <br>typedef struct MSG{ <br>IDD id; <br>const char * msg; <br>}MSG; </p>
<p>MSG _msg[] = {FILL(OPEN), FILL(CLOSE)}; <br>相当于： <br>MSG _msg[] = {{OPEN, "OPEN"}, <br>{CLOSE, "CLOSE"}}; </p>
<p>3、记录文件名 <br>#define _GET_FILE_NAME(f) #f <br>#define GET_FILE_NAME(f) _GET_FILE_NAME(f) <br>static char FILE_NAME[] = GET_FILE_NAME(__FILE__); </p>
<p>4、得到一个数值类型所对应的字符串缓冲大小 <br>#define _TYPE_BUF_SIZE(type) sizeof #type <br>#define TYPE_BUF_SIZE(type) _TYPE_BUF_SIZE(type) <br>char buf[TYPE_BUF_SIZE(INT_MAX)]; <br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; char buf[_TYPE_BUF_SIZE(0x7fffffff)]; <br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>&gt; char buf[sizeof "0x7fffffff"]; <br>这里相当于： <br>char buf[11];<b style="color:white;background-color:#886800">-</b></p>
<p>第3题:考查递归调用</p>
<p>int foo ( int x , int n)　{ int val; val =1;&nbsp;&nbsp;&nbsp; if (n&gt;0)&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp; if (n%2 == 1) val = val *x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = val * foo(x*x , n/2); } return val;} <br>这段代码对x和n完成什么样的功能(操作)?<br>(a) x^n (x的n次幂)<br>(b) x*n(x与n的乘积)<br>(c) n^x(n的x次幂)<br>(d) 以上均不是</p>
<p><br>第6题目:考查逗号表达式<br>main(){ int a, b,c, d; a=3; b=5; c=a,b; d=(a,b); printf("c=%d" ,c); printf("d=%d" ,d);}<br>这段程序的输出是:<br>(a)&nbsp;c=3 d=3<br>(b) c=5 d=3<br>(c) c=3 d=5<br>(d) c=5 d=5<br>第6题: (c)<br>考查逗号表达式,逗号表达式的优先级是很低的，比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值<br>逗号表达式的还有一个作用就是分割函数的参数列表..</p>
<p><br>第9题:考查自加操作(++)</p>
<p>main(){ int i=3; int j; j = sizeof(++i+ ++i); printf("i=%d j=%d", i ,j);}<br>这段程序的输出是:<br>(a)&nbsp;i=4 j=2<br>(b) i=3 j=2<br>(c) i=3 j=4<br>(d) i=3 j=6<br>第9题: (b)<br>sizeof 操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.( ++i + ++ i )是不会执行的，所以<br>i 的值还是3<br>第10题:考查形式参数，实际参数，指针和数组<br>void f1(int *, int); void f2(int *, int); void(*p[2]) ( int *, int);main(){ int a; int b; p[0] = f1; p[1] = f2; a=3; b=5; p[0](&amp;a , b); printf("%d/t %d/t" , a ,b); p[1](&amp;a , b); printf("%d/t %d/t" , a ,b);}void f1( int* p , int q){ int tmp; tmp =*p; *p = q; q= tmp;}void f2( int* p , int q){ int tmp; tmp =*p; *p = q; q= tmp;} <br>这段程序的输出是:<br>(a) 5 5 5 5</p>
<p>第11题:考查自减操作(<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>)<br>void e(int );&nbsp;&nbsp; main(){ int a; a=3; e(a);}void e(int n){ if(n&gt;0) {&nbsp;&nbsp;&nbsp; e(<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>n);&nbsp;&nbsp;&nbsp; printf("%d" , n);&nbsp;&nbsp;&nbsp; e(<b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b>n); }}<br>这段程序的输出是:<br>(a) 0 1 2 0</p>
<p>第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会也情有可原呵呵,<br>#include<stdarg.h><br>int ripple ( int , ...);<br>&nbsp;<br>main()<br>{<br>&nbsp;&nbsp;&nbsp; int num;<br>&nbsp;&nbsp;&nbsp; num = ripple ( 3, 5,7);<br>&nbsp;&nbsp;&nbsp; printf( " %d" , num);<br>}<br>&nbsp;<br>&nbsp;<br>int ripple (int n, ...)<br>{<br>&nbsp;&nbsp;&nbsp; int i , j;<br>&nbsp;&nbsp;&nbsp; int k;<br>&nbsp;&nbsp;&nbsp; va_list p;<br>&nbsp;&nbsp;&nbsp; k= 0; j = 1;<br>&nbsp;&nbsp;&nbsp; va_start( p , n);<br>&nbsp;&nbsp;&nbsp; for (; j<n; ++j)<br="">&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = va_arg( p , int);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (; i; i &amp;=i<b style="color:white;background-color:#886800">-</b>1 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++k;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return k;<br>}<br>这段程序的输出是:<br>(a) 7<br>(b) 6<br>(c) 5<br>(d) 3<br>第15题: (c)<br>在C编译器通常提供了一系列处理可变参数的宏，以屏蔽不同的硬件平台造成的差异，增加程序的可移植性。这些宏包括va_start、 va_arg和va_end等。 <br>采用ANSI标准形式时，参数个数可变的函数的原型声明是： <br>type funcname(type para1, type para2, ...) <br>这种形式至少需要一个普通的形式参数，后面的省略号不表示省略，而是函数原型的一部分。type是函数返回值和形式参数的类型。<br>不同的编译器，对这个可变长参数的实现不一样 ，gcc4.x中是内置函数.<br>关于可变长参数,可参阅</n;></stdarg.h></p>
<p><a href="http://www.upsdn.net/html/2004-11/26.html" target="_blank">http://www.upsdn.net/html/2004<b style="color:white;background-color:#886800">-</b>11/26.html</a><br><a href="http://www.upsdn.net/html/2004-11/24.html" target="_blank">http://www.upsdn.net/html/2004<b style="color:white;background-color:#886800">-</b>11/24.html</a></p>
<p>程序分析<br>va_list p; &nbsp;/*定义一个变量 ,保存函数参数列表 的指针*/<br>va_start( p , n);&nbsp;&nbsp;&nbsp;&nbsp; /*用va_start宏初始化变量p,&nbsp; va_start宏的第2个参数n, 是一个固定的参数,必须是我们自己定义的变长函数的最后一个入栈的参数也就是调用的时候参数列表里的第1个参数*/<br>for (; j<n; ++j)&nbsp;&nbsp;&nbsp;&nbsp;="" *="" j从1开始,&nbsp;&nbsp;="" 遍历所有可变参数="" <br="">{&nbsp;&nbsp;&nbsp; i = va_arg( p , int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*va_arg取出当前的参数,&nbsp; 并认为取出的参数是一个整数(int)*/&nbsp;&nbsp; <br>&nbsp;for (; i; i &amp;=i<b style="color:white;background-color:#886800">-</b>1 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*判断取出的i是否为0*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>++k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 如果i不为0,&nbsp;&nbsp; k自加, i与i<b style="color:white;background-color:#886800">-</b>1进行与逻辑运算, 直到i 为0&nbsp; 这是一个技巧，下面会谈到它的功能*/}<br>当我们调用ripple函数时，传递给ripple函数的 参数列表的第一个参数n的值是3 .<br>va_start 初始化 p指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).<br>每次对 va_arg的调用，都将返回一个参数，并且把 p 指向下一个参数.<br>va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数<br>(; i; i&amp;=i<b style="color:white;background-color:#886800">-</b>1) k++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 计算i有多少bit被置1 */<br>5用二进制表示是 (101) 2<br>7用二进制表示 (111) 3<br>所以 k 返回 5(2+3),也即本题应该选c</n;></p>
<p>因为i与i<b style="color:white;background-color:#886800">-</b>1的最右边的那位(最低位) 肯定是不同，如果i1,i<b style="color:white;background-color:#886800">-</b>1肯定是0，反之亦然.&nbsp;&nbsp;&nbsp;&nbsp; i &amp; i<b style="color:white;background-color:#886800">-</b>1 这个运算，在二相补的数字系统中，将会 消除最右边的1位<br>&nbsp;<br>1.　char * const p;<br>　　char const * p<br>　　const char *p</p>
<p>　　上述三个有什么区别？</p>
<p>　　char * const p; //常量指针，p的值不可以修改<br>　　char const * p；//指向常量的指针，指向的常量值不可以改<br>　　const char *p； //和char const *p<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><br>2.　char str1[] = "abc";<br>　　char str2[] = "abc";</p>
<p>　　const char str3[] = "abc";<br>　　const char str4[] = "abc";</p>
<p>　　const char *str5 = "abc";<br>　　const char *str6 = "abc";</p>
<p>　　char *str7 = "abc";<br>　　char *str8 = "abc";</p>
<p>　　cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;<br>　　cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;<br>　　cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;</p>
<p>　　cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;</p>
<p>&nbsp;&nbsp; 打印结果是什么？</p>
<p><br>解答：结果是：0 0 1 1<br>str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><br>3. 以下代码中的两个sizeof用法有问题吗？</p>
<p>　　void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母<br>　　{<br>&nbsp;&nbsp;&nbsp; 　　for( size_t i=0; i<sizeof(str) sizeof(str[0]);="" ++i="" )<br="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　if( 'a'&lt;=str[i] &amp;&amp; str[i]&lt;='z' )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str[i] <b style="color:white;background-color:#886800">-</b>= ('a'<b style="color:white;background-color:#886800">-</b>'A' );<br>　　}</sizeof(str)></p>
<p>　　char str[] = "aBcDe";<br>　　cout &lt;&lt; "str字符长度为: " &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;<br>　　UpperCase( str );<br>　　cout &lt;&lt; str &lt;&lt; endl;</p>
<p>答：函数内的sizeof有问题。<br>根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。<br>函数外的str是一个静态定义的数组，因此其大小为6，<br>函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>4.　main()<br>　　{<br>　　　int a[5]={1,2,3,4,5};<br>　　　int *ptr=(int *)(&amp;a+1);<br>　　　printf("%d,%d",*(a+1),*(ptr<b style="color:white;background-color:#886800">-</b>1));<br>　　}</p>
<p>&nbsp;&nbsp; 输出结果是什么？</p>
<p><br>　　答案：输出：2,5</p>
<p>　　*(a+1）就是a[1]，*(ptr<b style="color:white;background-color:#886800">-</b>1)就是a[4],执行结果是2，5<br>　　&amp;a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）<br>　　int *ptr=(int *)(&amp;a+1);<br>　　则ptr实际是&amp;(a[5]),也就是a+5<br>　　<br>　　原因如下：</p>
<p>　　&amp;a是数组指针，其类型为 int (*)[5];<br>　　而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。<br>　　a是长度为5的int数组指针，所以要加 5*sizeof(int)<br>　　所以ptr实际是a[5]<br>　　但是prt与(&amp;a+1)类型是不一样的(这点很重要)<br>　　所以prt<b style="color:white;background-color:#886800">-</b>1只会减去sizeof(int*)</p>
<p>　　a,&amp;a的地址是一样的，但意思不一样<br>&nbsp;&nbsp;&nbsp; a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，<br>&nbsp;&nbsp;&nbsp; a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5].<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>5.　请问以下代码有什么问题：</p>
<p>　　int&nbsp; main()<br>　　{<br>char a;<br>char *str=&amp;a;<br>strcpy(str,"hello");<br>printf(str);<br>return 0;<br>　　}</p>
<p>　　答案：没有为str分配内存空间，将会发生异常。问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>6. char* s="AAA";<br>　　printf("%s",s);<br>　　s[0]='B';<br>　　printf("%s",s);</p>
<p>　　有什么错？</p>
<p>　　答案：<br>"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>cosnt char* s="AAA";<br>然后又因为是常量，所以对是s[0]的赋值操作是不合法的。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>7. int (*s[10])(int) 表示的是什么？</p>
<p>　　答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>8.　有以下表达式：</p>
<p>　　int a=248; b=4;<br>　　int const c=21;<br>　　const int *d=&amp;a;<br>　　int *const e=&amp;b;<br>　　int const *f const =&amp;a;</p>
<p>　　请问下列表达式哪些会被编译器禁止？为什么？<br>　　*c=32;d=&amp;b;*d=43;e=34;e=&amp;a;f=0x321f;</p>
<p><br>　　答案：<br>&nbsp;&nbsp; *c 这是个什么东东，禁止<br>　　*d 说了是const， 禁止<br>　　e = &amp;a 说了是const 禁止<br>　　const *f const =&amp;a; 禁止<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>9.　#include <stdio.h><br>　　#include <stdlib.h></stdlib.h></stdio.h></p>
<p>　　void getmemory(char *p)<br>　　{　<br>　　　p=(char *) malloc(100);<br>　　　strcpy(p,"hello world");<br>　　}　</p>
<p>　　int main( )<br>　　{<br>　　　char *str=NULL;<br>　　　getmemory(str);<br>　　　printf("%s/n",str);<br>　　　free(str);<br>　　　return 0;<br>　　}</p>
<p>&nbsp;&nbsp; 分析一下这段代码</p>
<p>　　答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险<br>　　博主：getmemory中p是形参，是一个指针变量，getmemory(str)调用后，传入的是指针变量保存的对象地址，p=(char *) malloc(100)实际上是把申请的动态内存空间的首地址付给p指向的地址（即str指向的地址null），这个是错误的。应该修改成指向指针的指针void getmemory(char **p)，这样malloc返回的地址付给*p（即str变量本身）。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>10.　char szstr[10];<br>&nbsp; 　　strcpy(szstr,"0123456789");<br>&nbsp; 　　产生什么结果？为什么？<br>&nbsp;<br>　　答案：长度不一样，会造成非法的OS<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>11.要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;<br>&nbsp;&nbsp; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p>
<p>　　答案：*((void (*)( ))0x100000 ) ( );<br>　　首先要将0x100000强制转换成函数指针,即:<br>　　(void (*)())0x100000<br>　　然后再调用它:<br>　　*((void (*)())0x100000)();<br>　　用typedef可以看得更直观些:<br>　　typedef void(*)() voidFuncPtr;<br>　　*((voidFuncPtr)0x100000)();<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>12. 分析下面的程序：</p>
<p>　　void GetMemory(char **p,int num)<br>　　{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //p，指向指针的指针，*p，p指向的指针(即str)，**p，最终的对象，str指向的单元<br>　　　*p=(char *)malloc(num);&nbsp; //申请空间首地址付给传入的被p指向的指针，即str<br>　　}&nbsp;&nbsp; <br>&nbsp;&nbsp; <br>　　int main()<br>　　{<br>&nbsp;&nbsp;&nbsp;&nbsp; char *str=NULL;<br>　　　GetMemory(&amp;str,100);&nbsp;&nbsp; //传入指针变量本身的地址<br>　　　strcpy(str,"hello");<br>　　　free(str);</p>
<p>　　　if(str!=NULL)<br>　　　{<br>&nbsp; 　　　　strcpy(str,"world");<br>　　　}&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>　　　printf("/n str is %s",str); 软件开发网 <a href="http://www.mscto.com/" target="_blank">www.mscto.com</a><br>　　　getchar();<br>　　}&nbsp; </p>
<p>　　问输出结果是什么？</p>
<p>　　答案：输出str is world。</p>
<p>　　free 只是释放的str指向的内存空间,它本身的值还是存在的.所以free之后，有一个好的习惯就是将str=NULL.<br>此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,<br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。<br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。</p>
<p>　　当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>13.char a[10]；<br>strlen(a)为什么等于15？</p>
<p>　　#include "stdio.h"<br>　　#include "string.h"</p>
<p>　　void main()<br>　　{<br>　　　char aa[10];<br>　　　printf("%d",strlen(aa));</p>
<p>　　}</p>
<p>　　答案：sizeof()和初不初始化，没有关系；<br>　　strlen()和初始化有关。<br><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b><b style="color:white;background-color:#886800">-</b></p>
<p>14.char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/<br>　　char *str[20];/*str是一个指针数组，其元素为指针型数据．*/<br></p></div>                                   </div>
            <!-- <div class="Blog_con3_1">管理员在2009年8月13日编辑了该文章文章。</div> -->
            <div class="Blog_con2_1 Blog_con3_2">
              <div>
			  <!--<img src="/image/default/tu_8.png">-->
			  <!-- JiaThis Button BEGIN -->
				<div class="bdsharebuttonbox"><a class="bds_more" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="more"></a><a class="bds_qzone" title="分享到QQ空间" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="qzone"></a><a class="bds_tsina" title="分享到新浪微博" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="tsina"></a><a class="bds_tqq" title="分享到腾讯微博" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="tqq"></a><a class="bds_renren" title="分享到人人网" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="renren"></a><a class="bds_weixin" title="分享到微信" href="http://blog.chinaunix.net/uid-26384989-id-4703946.html#" data-cmd="weixin"></a></div>

				<!-- JiaThis Button END -->
			  </div>
              阅读(360) | 评论(0) | 转发(0) |
			                <div class="HT_line3"></div>
            </div>
            <div class="Blog_con3_3">
              <div><span id="digg_num">0</span><a href="javascript:void(0)" id="digg" bid="4703946" url="/blog/digg.html"></a></div>
              <p>上一篇：<a href="http://blog.chinaunix.net/uid-26384989-id-4701346.html">pthread_cond_signal()放置位置</a></p>
              <p>下一篇：<a href="http://blog.chinaunix.net/uid-26384989-id-4705526.html">linux系统 /proc/sys/net/ipv4/参数说明（转）</a></p>
            </div>
          </div>
          <div class="Blog_con3_4">
            <div class="Blog_tit2 Blog_tit6">相关热门文章</div>
			            <ul class="Blog_ul7">
						  <li><span class="Blog_span7"></span><a href="http://blog.chinaunix.net/uid-26615473-id-3056538.html" title="test123" target="blank">test123</a></li>
						  <li><span class="Blog_span7"></span><a href="http://blog.chinaunix.net/uid-23629988-id-3018793.html" title="编写安全代码――小心有符号数的右移操作" target="blank">编写安全代码――小心有符号数...</a></li>
						  <li><span class="Blog_span7"></span><a href="http://blog.chinaunix.net/uid-22889411-id-59688.html" title="彻底搞定C语言指针详解-完整版-时候初学者-必备" target="blank">彻底搞定C语言指针详解<b style="color:white;background-color:#886800">-</b>完整版...</a></li>
						  <li><span class="Blog_span7"></span><a href="http://blog.chinaunix.net/uid-233938-id-162619.html" title="使用openssl api进行加密解密" target="blank">使用openssl api进行加密解密...</a></li>
						  <li><span class="Blog_span7"></span><a href="http://blog.chinaunix.net/uid-233938-id-162628.html" title="一段自己打印自己的c程序" target="blank">一段自己打印自己的c程序...</a></li>
			            </ul>
            <ul class="Blog_ul7">
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785970" title="linux dhcp  peizhi roc" target="blank">linux dhcp  peizhi roc</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785964" title="关于Unix文件的软链接" target="blank">关于Unix文件的软链接</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785935" title="求教这个命令什么意思，我是新手，刚刚学习solaris" target="blank">求教这个命令什么意思，我是新...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785919" title="sed -e &quot;/grep/d&quot; 是什么意思？谢谢" target="blank">sed <b style="color:white;background-color:#886800">-</b>e "/grep/d" 是什么意思...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785702" title="谁能够帮我解决LINUX  2.6  10版本驱动" target="blank">谁能够帮我解决LINUX  2.6  10...</a></li>
			            </ul>
            <div class="clear"></div>
          </div>
		  <!--
          <div class="Blog_con3_4 Blog_con3_5">
            <div class="Blog_tit2 Blog_tit7">热门推荐</div>
            <ul>
			              <li><a href="" title="" target='blank' ></a></li>
			            </ul>
          </div>
		  -->
        </div>
      </div>
      <div class="Blog_right1_7" id="replyList">
		<div class="Blog_tit3">给主人留下些什么吧！~~</div>
				<!--暂无内容-->
				<!-- 评论分页-->
		<div class="Blog_right1_6 Blog_right1_12">
        		</div>
		<!-- 评论分页-->
        <div class="Blog_right1_10">
          <div class="Blog_tit3">评论热议</div>
		  		 <!--未登录 -->
        <div class="Blog_right1_8">
          <div class="nologin_con1"> 请登录后评论。
            <p><a href="http://blog.chinaunix.net/site/login.html" onclick="linkto()">登录</a> <a href="http://sso.chinaunix.net/Register?return_url=http%3A%2F%2Ft.cublog.com%2F">注册</a></p>
          </div>
        </div>
        <br>
        <div>
            <div style="float:left;margin-left:70px;margin-right:10px;">
             
            
            </div>
            <div style="margin-left:10px;">
            
            
            </div>
        </div>
		
        </div>
      </div>
    </div>
  </div>
  <input type="hidden" id="report_url" value="/blog/ViewReport.html">


<!--该部分应该放在输出代码块的后面才起作用 -->

<!--回顶部js2011.12.30-->
  <!-- footer -->
  <div class="Blog_footer" style="clear:both">
    <div><a href="http://www.chinaunix.net/about/index.shtml" target="_blank" rel="nofollow">关于我们</a> | <a href="http://www.it168.com/bottomfile/it168.shtml" target="_blank" rel="nofollow">关于IT168</a> | <a href="http://www.chinaunix.net/about/connect.html" target="_blank" rel="nofollow">联系方式</a> | <a href="http://www.chinaunix.net/about/service.html" target="_blank" rel="nofollow">广告合作</a> | <a href="http://www.it168.com//bottomfile/flgw/fl.htm" target="_blank" rel="nofollow">法律声明</a> | <a href="http://sso.chinaunix.net/Register?return_url=http%3A%2F%2Fblog.chinaunix.net%2F" target="_blank" rel="nofollow">免费注册</a>
      <p>Copyright  2001<b style="color:white;background-color:#886800">-</b>2010 ChinaUnix.net All Rights Reserved 北京皓辰网域网络信息技术有限公司. 版权所有 </p>
      <div>感谢所有关心和支持过ChinaUnix的朋友们
        <p>京ICP证041476号 京ICP证060528号</p>
      </div>
    </div>
  </div>
</div>









</div>



</body></html>